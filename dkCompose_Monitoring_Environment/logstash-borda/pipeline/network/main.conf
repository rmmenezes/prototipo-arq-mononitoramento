input {
    # REST API port 5000
    beats {
		port => 5000
        type => json
        ssl_verify_mode => "none"
        ssl_certificate => "/usr/share/logstash/certs/BeatsLogstash.crt.pem"
        ssl_key => "/usr/share/logstash/certs/BeatsLogstash.key.pem"
        ssl => true
	}
}


filter{
    # Drop Elasticsearch Bulk API control lines
    if ([message] =~ '\{"index"') {
        drop {}
    }

	json{
		source => "message"
	 	target => "packet"
	}
    
    # Remove pacotes com headers gerados pela comunicação tcp com o logstash
    if ![packet]{
        drop {}
    }

    # Adiciona cordenadas geográficas (IP)
	if [packet][layers][ip] or [packet][layers][ipv6] {

        # IPV4
        if [packet][layers][ip] {
            # GeoIP para endereços de Origem
            geoip {
                source => "[packet][layers][ip][ip_ip_src]"
                target => "source"
            }

            # GeoIP para endereços de Destino
            geoip {
                source => "[packet][layers][ip][ip_ip_dst]"
                target => "dest"
            }
            

            # Caso não encontrado localização para o IP Source, verificar em um dicionario pre-definido
            if ![source][location] {
                translate {
                    exact => true
                    regex => true
                    override => true
                    field => "[packet][layers][ip][ip_ip_src]"
                    destination => "geo_point_source"
                    dictionary_path => "/usr/share/logstash/pipeline/database/databaseGeoIPLocal.yml"
                    fallback => '{"timezone":"America/New_York","continent_code":"NA","country_name":"United States","country_code2":"US","country_code3":"US","region_name":"New York","latitude":28.046,"longitude":-82.6848,"location":{"lat":28.046,"lon":-82.6848}}'
                    refresh_behaviour => "replace"
                }
                json {
                    source => "geo_point_source"
                    target => "source"
                    add_field => { "[source][ip_ip_src]" => "%{[packet][layers][ip][ip_ip_src]}" }
                    remove_field => [ "geo_point_source" ]
                }
                mutate {
                    remove_tag => [ "_geoip_lookup_failure" ]
                }
            }

            # Caso não encontrado localização para o IP Destino, verificar em um dicionario pre-definido
            if ![dest][location] {
                translate {
                    exact => true
                    regex => true
                    override => true
                    field => "[packet][layers][ip][ip_ip_dst]"
                    destination => "geo_point_dest"
                    dictionary_path => "/usr/share/logstash/pipeline/database/databaseGeoIPLocal.yml"
                    fallback => '{"timezone":"America/New_York","continent_code":"NA","country_name":"United States","country_code2":"US","country_code3":"US","region_name":"New York","latitude":28.046,"longitude":-82.6848,"location":{"lat":28.046,"lon":-82.6848}}'
                    refresh_behaviour => "replace"
                }
                json {
                    source => "geo_point_dest"
                    target => "dest"
                    add_field => { "[dest][ip_ip_dst]" => "%{[packet][layers][ip][ip_ip_dst]}" }
                    remove_field => [ "geo_point_dest" ]
                }
                mutate {
                    remove_tag => [ "_geoip_lookup_failure" ]
                }
            }

            if [source][ip] { mutate {rename => ["[source][ip]", "[source][ip_ip_src]"]}}
            if [dest][ip] { mutate {rename => ["[dest][ip]", "[dest][ip_ip_dst]"]}}
        }


        # IPV6
        if [packet][layers][ipv6] {
            # GeoIP para endereços de Origem
            geoip {
                source => "[packet][layers][ipv6][ipv6_ipv6_src]"
                target => "source"
            }

            # GeoIP para endereços de Destino
            geoip {
                source => "[packet][layers][ipv6][ipv6_ipv6_dst]"
                target => "dest"
            }

            # Caso não encontrado localização para o IP Source, verificar em um dicionario pre-definido
            if ![source][location] {
                translate {
                    exact => true
                    regex => true
                    override => true
                    field => "[packet][layers][ipv6][ipv6_ipv6_src]"
                    destination => "geo_point_source"
                    dictionary_path => "/usr/share/logstash/pipeline/database/databaseGeoIPLocal.yml"
                    fallback => '{"timezone":"America/New_York","continent_code":"NA","country_name":"United States","country_code2":"US","country_code3":"US","region_name":"New York","latitude":28.046,"longitude":-82.6848,"location":{"lat":28.046,"lon":-82.6848}}'
                    refresh_behaviour => "replace"
                }
                json {
                    source => "geo_point_source"
                    target => "source"
                    add_field => { "[source][ip]" => "%{[packet][layers][ipv6][ipv6_ipv6_src]}" }
                    remove_field => [ "geo_point_source" ]
                }
                mutate {
                    remove_tag => [ "_geoip_lookup_failure" ]
                }
            }

            # Caso não encontrado localização para o IP Destino, verificar em um dicionario pre-definido
            if ![dest][location] {
                translate {
                    exact => true
                    regex => true
                    override => true
                    field => "[packet][layers][ipv6][ipv6_ipv6_dst]"
                    destination => "geo_point_dest"
                    dictionary_path => "/usr/share/logstash/pipeline/database/databaseGeoIPLocal.yml"
                    fallback => '{"timezone":"America/New_York","continent_code":"NA","country_name":"United States","country_code2":"US","country_code3":"US","region_name":"New York","latitude":28.046,"longitude":-82.6848,"location":{"lat":28.046,"lon":-82.6848}}'
                    refresh_behaviour => "replace"
                }
                json {
                    source => "geo_point_dest"
                    target => "dest"
                    add_field => { "[dest][ip]" => "%{[packet][layers][ipv6][ipv6_ipv6_dst]}" }
                    remove_field => [ "geo_point_dest" ]
                }
                mutate {
                    remove_tag => [ "_geoip_lookup_failure" ]
                }
            }

            if [source][ip] { mutate {rename => ["[source][ip]", "[source][ipv6_ipv6_src]" ]}}
            if [dest][ip] { mutate {rename => ["[dest][ip]", "[dest][ipv6_ipv6_dst]" ]}}
        }

        # Traduz os valores numericos de protocolos (IPV4).
        if [packet][layers][ip] {
            translate {
                exact => true
                regex => true
                override => true
                field => "[packet][layers][ip][ip_ip_proto]"
                destination => "protocol"
                dictionary_path => "/usr/share/logstash/pipeline/database/databaseProtocolList.json"
                fallback => '{"Keyword": "", "Protocol": "Unassigned"}'
                refresh_behaviour => "replace"
            }
            mutate { add_field => { "[protocol][Protocol_number]" => "%{[packet][layers][ip][ip_ip_proto]}" }}
        }

        # Traduz os valores numericos de protocolos (IPV6).
        if [packet][layers][ipv6] {
            translate {
                exact => true
                regex => true
                override => true
                field => "[packet][layers][ipv6][ipv6_ipv6_nxt]"
                destination => "protocol"
                dictionary_path => "/usr/share/logstash/pipeline/database/databaseProtocolList.json"
                fallback => '{"Keyword": "", "Protocol": "Unassigned"}'
                refresh_behaviour => "replace"
            }
            mutate { add_field => { "[protocol][Protocol_number]" => "%{[packet][layers][ipv6][ipv6_ipv6_nxt]}" }}
        }


    }
    
    mutate {
		remove_field => ["port","log","ecs","input","type","@version","message","host","path","tags", "@version"]
	} 

}

output {
    # Direciona o fluxo de dados para o pipelineMongoDB responsavel pelo armazenamento crú dos arquivos
    pipeline { send_to => networkMongoDB }
    
    # Direciona o fluxo de dados para o pipelineElasticSearch responsavel pela filtragem/tratamento e indexação
    pipeline { send_to => networkElasticsearch }
}